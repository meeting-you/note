{"./":{"url":"./","title":"Introduction","keywords":"","body":"学习笔记 常用Linux相关 VIM常用命令 常用网站 GitHub B站 google搜索 VPN 华为主题 证书相关 马哥openssl和ssh 资料官网 Apollo Dubbo XXL-Job AKKA 2.3.6 Scala 文档 规则引擎：drools 缓存 alibaba/jetcache 微服务 alibaba/spring-cloud-alibaba alibaba/Sentinel 日志链路 cat opentracing Redis redisson:Redis客户端 lettuce:Redis客户端 redis中文网 Redis命令参考简体中文版 jedis:Redis客户端 数据库插件 sharding-jdbc shardingsphere首页 cassandra cassandra:官网 数据库审计 Archery:SQL审核平台 Archery-GitHub:SQL审核平台 archer-GitHub:SQL审核平台 运维与监控 prometheus prometheus：官网 Prometheus hotspot监控指标解读 域名解析设置方法 ceph存储 Kubernetes:中文社区 jumpserver:浏览器管理机器 物联网 thingsboard emqx EMQ黑马视频 Spring springcloud中文网 spring-boot官网 Mybatis Mybatis自动生成表 MyBatis中文官网 MyBatis插件 MyBatis-Plus 文档笔记 jamstack:静态站点自动生成 GitBook 测试 testng-xml使用 JVM Alibaba/arthas:在线JVM调试 首页 arthas:黑马视频教程 OracleJDK OpenJDK JavaCC:一个用JAVA开发的最受欢迎的语法分析生成器， JSQLParser用到 reflections:Java反射包 Java堆分析器 - Eclipse Memory Analyzer Tool(MAT) 版本管理 Gradle Gradle In Action(Gradle实战)中文版 Gradle User Guide 中文版 算法 极客时间：数据结构与算法之美 leetcode var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 15:51:45 "},"doc/GitBook/":{"url":"doc/GitBook/","title":"GitBook笔记","keywords":"","body":"GitBook学习笔记 GitBook安装笔记 GitBook使用笔记 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/GitBook/GitBook安装笔记.html":{"url":"doc/GitBook/GitBook安装笔记.html","title":"安装笔记","keywords":"","body":"GitBook安装笔记 Mac安装 安装nodejs brew install node 淘宝加速 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装GitBook npm install -g gitbook-cli 查看 gitbook --version GitBook使用 构建 gitbook build 本地测试 gitbook serve 访问 http://localhost:4000/ 自动GitHub代码 要求： 主分支为main 展示分支为page 对/var/gitbook/_book 目录有读写权限#！/bin/bash #curPath = $(pwd) #echo $curPath echo \"提交\" git commit -asm \"auto commit\" git push origin main # 删除重建 doc rm -rf doc mkdir doc cp -R gbook/ doc/ sh gitalk.sh git add . git commit -asm \"auto commit\" git push origin main # 删除旧的缓存目录重建 echo \"删除旧_book目录\" rm -rf /var/gitbook/_book/gitbook_test mkdir -p /var/gitbook/_book/gitbook_test echo \"安装插件\" gitbook install ./ echo \"生成_book\" gitbook build echo \"拷贝\" cp -R ../gitbook_test/_book /var/gitbook/_book/gitbook_test echo \"切换分支\" git checkout page sleep 2 echo \"删除旧文件\" shopt -s extglob rm -rf !(.idea | .gitignore) echo \"恢复\" cp -R /var/gitbook/_book/gitbook_test/_book/* ../gitbook_test/ sleep 2 echo \"提交page\" git add . git commit -asm \"autocommitpage\" && git push origin page sleep 2 echo \"check main\" git checkout main var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/GitBook/GitBook使用笔记.html":{"url":"doc/GitBook/GitBook使用笔记.html","title":"使用笔记","keywords":"","body":"GitBook使用笔记 GitBook使用很简单 目录结构 1. README.md //初始化文档，生成介绍说明 2. SUMMARY.md // 目录 * [GitBook笔记](GitBook/README.md)，多级目录用tab键分隔 3. 书写内容用Markdown Markdown 表格 title1 title2 title3 1 2 3 gitbook不支持Markdown的toc自动生成目录 参考：https://blog.csdn.net/u012887259/article/details/102425695 脚本地址：https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc 使用方式： sh ../../gh-md-toc.sh ghMdTocTest.md 拷贝打印的到文件任意处即目录： * [一级标题](#一级标题) * [1. 二级标题](#1-二级标题) * [2. 二级标题2](#2-二级标题2) * [第二个一级标题](#第二个一级标题) 插件参考 参考地址参考地址2 评论插件 参考地址js地址 上面评论插件不实用： 参考：https://zhuanlan.zhihu.com/p/136192511 { \"plugins\": [\"valine\"], \"pluginsConfig\": { \"valine\": { \"appId\": \"your appId\", \"appKey\": \"your appKey\" } } } Valine 文档管理台价格及限制 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/gh-md-toc-test/ghMdTocTest.html":{"url":"doc/gh-md-toc-test/ghMdTocTest.html","title":"gh-md-toc测试","keywords":"","body":" 一级标题 1. 二级标题 2. 二级标题2 第二个一级标题 一级标题 啦啦啦 sd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdf 1. 二级标题 sd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdf 2. 二级标题2 sd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdf 第二个一级标题 sd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdfsd sdf sdf sdf sdf var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/ThingsBoard/":{"url":"doc/ThingsBoard/","title":"ThingsBoard","keywords":"","body":"ThingsBoard学习笔记 官网物联网（英语：Internet of Things，简称IoT）是一种计算设备、机械、数字机器相互关系的系统，具备通用唯一识别码（UID），并具有通过网络传输数据的能力，无需人与人、或是人与设备的交互 1. ThingsBoard了解 说明 1. zkClient使用的是Apache Curator var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/ThingsBoard/ThingsBoard了解.html":{"url":"doc/ThingsBoard/ThingsBoard了解.html","title":"ThingsBoard了解","keywords":"","body":"ThingsBoard入门 物联网（英语：Internet of Things，简称IoT） 1. ThingsBoard是什么? ThingsBoard是一个开源物联网平台，可实现物联网项目的快速开发、管理和扩展。 特点 ThingsBoard可用于: 设备管理，资产和客户并定义他们之间的关系。 基于设备和资产收集数据并进行可视化。 采集遥测数据并进行相关的事件处理进行警报响应。 基于远程RPC调用进行设备控制。 基于生命周期事件、REST API事件、RPC请求构建工作流。 基于动态设计和响应仪表板向你的客户提供设备或资产的遥测数据。 基于规则链自定义特定功能。 发布设备数据至第三方系统。 ThingsBoard设计原则: 高扩展: 使用领先开源技术构建的可水平扩展平台。 高容错：无单点故障集群中的每个节点都是相同的。 高性能：单个服务器节点可以根据用例处理几十甚至数十万个设备，集群可以处理数百万台设备。 高灵活：开发新功能可以方便的使用自定义部件、规则引擎等。 持久化：数据永久保存 2. 入门 别人GitHub源码阅读源码 1. 基于Docker安装ThingsBoard 参考：官方镜像：官方 -p 9090:9090 -将本地端口9090连接到公开的内部HTTP端口9090 -p 1883:1883 -将本地端口1883连接到暴露的内部MQTT端口1883 -p 5683:5683 -将本地端口5683连接到裸露的内部COAP端口5683 docker pull thingsboard/tb-postgres:3.2.2 docker run -d --restart=always --network mynetwork --network-alias mytb -e TB_QUEUE_TYPE=kafka -e TB_KAFKA_SERVERS=mykafka:9092 -p 9090:9090 -p 1883:1883 -p 5683:5683/udp --name mytb thingsboard/tb-postgres:3.2.2 浏览器访问： http://localhost:9090/home 登录账号 Systen Administrator: sysadmin@thingsboard.org / sysadmin Tenant Administrator: tenant@thingsboard.org / tenant Customer User: customer@thingsboard.org / customer 2. 入门了解 ThingsBoard的基本用法 创建资产和设备; 定义资产和设备间的关系; 发送设备数据至ThingsBoard; 创建实时仪表板; 定义阀值并报警; 将警报通过邮件发送. var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/emqx/":{"url":"doc/emqx/","title":"emqx","keywords":"","body":"EMQ学习笔记 官网 1. EMQ了解 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/emqx/EMQ了解.html":{"url":"doc/emqx/EMQ了解.html","title":"EMQ了解","keywords":"","body":"EMQ入门笔记 参考：官网 1. 安装 docker安装 参考：地址镜像：地址 docker pull emqx/emqx:4.3.0 docker run -d --restart=always --network mynetwork --network-alias myemqx --name myemqx -p 21883:1883 -p 28081:8081 -p 28083:8083 -p 28883:8883 -p 28084:8084 -p 18083:18083 emqx/emqx:4.3.0 访问 http://localhost:18083 默认用户名是 admin，密码是 public 占用端口说明 参考：https://www.dreamchan.cn/posts/55717.html 1883: MQTT 协议端口 8883: MQTT/SSL 端口 8083: MQTT/WebSocket 端口 8084: MQTT/wss 端口 8081: HTTP API 端口 18083: Dashboard 管理控制台端口 1883 MQTT/TCP 协议端口 11883 MQTT/TCP 协议内部端口，仅用于本机客户端连接 8883 MQTT/SSL 协议端口 8083 MQTT/WS 协议端口 8084 MQTT/WSS 协议端口 2. var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/emqx/黑马EMQ笔记/":{"url":"doc/emqx/黑马EMQ笔记/","title":"黑马EMQ笔记","keywords":"","body":"EMQ MQTT协议 协议介绍 设计规范 主要特性 应用领域 协议原理 协议实现方式 网络传输与应用消息 MQTT客户端 MQTT服务端 发布/订阅，主题，会话 MQTT协议中的方法 协议数据包结构 固定头 可变头 消息体 EMQX基础功能 EMQX简介 emqx是什么 为什么选择emqx emqx与物联网平台的关系 emqx有哪些产品 emqx消息服务器功能列表 emqx服务端环境搭建 客户端websocket消息收发 Dashboard 查看和配置Dashboard Dashboard界面 ADMIN MONITORING RULE ENGINE MANAGEMENT TOOLS 认证 认证简介 认证方式 认证流程 username认证 预设认证数据 http api 管理认证数据 mqttx客户端验证 client id认证 预设认证数据 http api 管理认证数据 mqttx 客户端验证 http认证 认证原理 http请求信息 认证请求 认证服务开发 mqttx客户端验证 客户端sdk Eclipse Paho Java Paho介绍 Paho实现消息收发 MQTT.js API列表 MQTT.js实现消息收发 日志与追踪 控制日志输出 日志级别 日志文件和日志滚动 针对日志级别输出日志文件 日志格式 日志级别和log handlers 运行时修改日志级别 日志追踪 EMQX高级功能 发布订阅ACL 发布订阅ACL简介 ACL 插件 ACL规则详解 授权结果 全局配置 超级用户 ACL缓存 ACL 鉴权链 内置ACL 定义ACL acl.conf 编写规则 HTTP ACL ACL授权原理 HTTP 请求信息 superuser 请求 ACL 授权查询请求 HTTP ACL接口开发 HTTP ACL接口测试 WebHook WebHook简介 配置项说明 Webhook实现客户端断连监控 断连监控需求 断连监控代码实现 断连监控测试 EMQ X集群 EMQ X 集群概述 EMQ X 分布式集群设计 订阅表: 主题 - 订阅者 路由表: 主题 - 节点 主题树: 带通配符的主题匹配 消息派发过程 节点发现与自动集群 manual方式管理集群实践 配置节点1 配置节点2 节点加入集群 退出集群 集群脑裂与自动愈合 集群节点自动清除 管理监控API的使用 接口安全及响应码 核心关键API 保留消息 简介 保留消息配置 共享订阅 简介 带群组的共享订阅 不带群组的共享订阅 均衡策略与派发 Ack 配置 延迟发布 简介 延迟发布案例 代理订阅 内置代理订阅 开启代理订阅 配置代理订阅规则 基于Webhook和API实现动态代理订阅 动态代理订阅需求 代码实现及测试 主题重写 简介 配置主题重写规则 主题重写配置验证 黑名单 简介 获取黑名单 添加黑名单 删除黑名单 速率限制 速率限制简介和配置 速率限制原理 令牌桶算法在EMQX中的应用 飞行窗口和消息队列 简介 飞行队列与Receive Maximum 消息重传 简介 消息重传基础配置 规则引擎 规则引擎概述 简介 应用场景 规则引擎的组成 SQL语句 SQL语法 SQL语句相关示例 SQL事件和字段 SQL 运算符和函数 Dashboard中测试SQL语句 规则引擎案例 创建资源 创建规则 创建资源webhook接口 系统调优 Linux 操作系统参数 TCP 协议栈网络参数 Erlang 虚拟机参数 EMQ X 消息服务器参数 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/emqx/黑马EMQ笔记/EMQ_导学讲义.html":{"url":"doc/emqx/黑马EMQ笔记/EMQ_导学讲义.html","title":"EMQ_导学讲义","keywords":"","body":"物联网消息引擎：EMQ X 课程背景 1、5G 时代，万物互联 随着5G的到来，万物互联已经成为现实，物联网行业得以蓬勃发展，催生了很多的应用，比如：物联网pass平台，车联网，面向云平台的IOT-Hub，NB-IoT蜂窝网络，新零售等等，而开发这些应用的核心要素就是物联网设备和平台之间的数据交换，并且要兼备高并发低时延，支持分布式集群等特点，因此打造一款助力构建 5G 时代物联网平台与应用的消息引擎显得尤为重要，而EMQ X则是首选方案。 2、真实的企业需求 一大批先行企业抓住了这个行业风口想做出很好的产品，因此也需要大批的技术人员来帮助他们实现，其中不乏有很多底蕴丰厚，前景广阔的平台。 3、开发人员现状 市场中具备相应能力的开发人员不多，因此需要一门课程帮助他们来提高。 课程概述 本课程从物联网消息通信协议MQTT出发，从协议的原理，数据包的结构，到遵循该协议的消息引擎EMQX，完整的讲授了EMQX Broker消息处理服务器的基础功能及高级功能的使用，帮助学员快速掌握物联网消息引擎EMQX 课程特色 为什么推荐大家学习这们课？ 1：开源社区最受欢迎的物联网消息引擎，5G 时代大型物联网应用首选技术方案 2：EMQX 助力构建 5G 时代物联网平台与应用；海量物联网设备一站式连接；高并发低时延，大规模分布式，高可用集群架构；强大规则引擎，快速应用集成；边缘到云端，云端到跨云部署 3：完整 MQTT 协议支持，完全开放源码 课程内容 本课程的目标是： 1：理解MQTT协议的设计原理和具体的数据结构 2：能够独立使用EMQX 消息服务器的基础功能和高级功能 课程大纲如下： EMQX Broker中的Dashboard页面展示如下： 学习收获 学习完本课程我们能具备以下能力： 1：能够掌握MQTT这种基于发布/订阅模式的物联网消息通信协议，理解其原理和实现方式，对协议的数据格式非常清楚，能有效应对面试及工作 2：能够搭建EMQX Broker消息服务器环境，掌握它的基本使用步骤。 3：能够使用EMQX Broker轻松连接物联网设备，完成设备端的身份认证和数据双向通信。 4：能够掌握EMQX Broker消息发布/订阅的ACL权限控制，WebHook网络钩子，集群的搭建和使用。 5：能够掌握EMQX Broker中的保留消息，共享订阅，延迟发布，代理订阅，主题重写，黑名单，速率限制，规则引擎等功能。 适用人群 目标人群： 1：想要从事物联网行业的技术人员 2：想要完善物联网技术体系的IT人员 3：毕业想从事java开发工作且跟物联网相关的大学生 知识储备： 1：具备一定的Java基础 2：具备基本的springboot使用能力 3：了解计算机网络的基础知识 环境和软件版本 1：java：8 2：EMQX Broker 4.5 3：docker/linux-centos7 4：IDEA2017以上版本 5：maven3.5.x以上版本 6：MQTTX客户端 7：Visual Studio code 学习方法及建议 1：多动手，课前预习，课后复习，代码一定要手动敲，避免CV,主动记笔记 2：多动眼，除了要仔细看课程提供的讲义外，还要主动阅读相关技术的操作文档 3：多动口，对于课程中不懂的知识点要主动咨询，多和同学/同事交流学习的心得 4：多动脑，对于一些技术点要主动的思考其底层的原理，要知其然还要知其所以然 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/emqx/黑马课程学习笔记/":{"url":"doc/emqx/黑马课程学习笔记/","title":"黑马课程学习笔记","keywords":"","body":"笔记 物联网与互联网的区别与联系 互联网： 互联网（internet），又称国际网络，指的是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。 物联网： 物联网（ IoT ，Internet of things ）即“万物相连的互联网”，是互联网基础上的延伸和扩展的网络，将各种信息传感设备与网络结合起来而形成的一个巨大网络， 实现在任何时间、任何地点，人、机、物的互联互通 MQTT 1. MQTT协议的概念，特点及作用 2. 发布/订阅，代理，主题，会话，服务质量的相关概念，MQTT协议中的动作 3. MQTT协议的组成，固定头中的组成结构，可变头主要的组成结构 4. EMQ X是什么，完成EMQ X Broker环境搭建以及websocket客户端完成消息数据的收发 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/emqx/黑马课程学习笔记/MQTT协议.html":{"url":"doc/emqx/黑马课程学习笔记/MQTT协议.html","title":"MQTT协议","keywords":"","body":"MQTT协议 背景 随着 5G 时代的来临，万物物联的伟大构想正在成为现实。联网的物联网设备在 2018 年已经达到了 70 亿，在未来两年，仅智能水电气表就将超过10亿 海量的设备接入和设备管理对网络带宽、通信协议以及平台服务架构都带来了很大挑战。 对于物联网协议来说，必须针对性地解决物联网设备通信的几个关键问题： 其网络环境复杂而不可靠、 其内存和闪存容量小、 其处理器能力有限。 MQTT 是基于 Publish/Subscribe 模式的物联网通信协议，凭借简单易实现、支持 QoS、报文小等特点，占据了物联网协议的半壁江山： MQTT协议介绍 mqtt官网mqtt中文网MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的\"轻量级\"通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 MQTT协议设计规范 （1）精简，不添加可有可无的功能； （2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递，解耦Client/Server模式，带来的好处在于不必预先知道对方的存在（ip/port），不必同时运行； 消息中间件模式 （3）允许用户动态创建主题（不需要预先创建主题），零运维成本； （4）把传输量降到最低以提高传输效率； （5）把低带宽、高延迟、不稳定的网络等因素考虑在内； （6）支持连续的会话保持和控制（心跳）； （7）理解客户端计算能力可能很低； （8）提供服务质量（quality of service level：QoS）管理； （9）不强求传输数据的类型与格式，保持灵活性（指的是应用层业务数据）。 MQTT协议主要特性 MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： （1）开放消息协议，简单易实现。 （2）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。 （3）对负载（协议携带的应用数据）内容屏蔽的消息传输。 （4）基于TCP/IP网络连接,提供有序，无损，双向连接。 主流的MQTT是基于TCP连接进行数据推送的， 但是同样有基于UDP的版本，叫做MQTT-SN。 这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 （5）消息服务质量（QoS）支持，可靠传输保证；有三种消息发布服务质量： QoS0：\"至多一次\"，消息发布完全依赖底层TCP/IP网络。 会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。 QoS1：\"至少一次\"，确保消息到达，但消息重复可能会发生。 QoS2：\"只有一次\"，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。 在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。 （6）1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量。 这就是为什么在介绍里说它非常适合\"在物联网领域，传感器与服务器的通信，信息的收集，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。 （7）在线状态感知：使用Last Will和Testament特性通知有关各方客户端异常中断的机制。 Last Will：即遗言机制，用于通知同一主题下的其他设备，发送遗言的设备已经断开了连接。 Testament：遗嘱机制，功能类似于Last Will。 MQTT协议应用领域 MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域。 物联网M2M通信，物联网大数据采集 Android消息推送，WEB消息推送 移动即时消息，例如Facebook Messenger 智能硬件、智能家具、智能电器 车联网通信，电动车站桩采集 智慧城市、远程医疗、远程教育 电力、石油与能源等行业市场 MQTT协议原理 MQTT协议实现方式 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 网络传输与应用消息 MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。 MQTT客户端 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： （1）发布其他客户端可能会订阅的信息； （2）订阅其它客户端发布的消息； （3）退订或删除应用程序的消息； （4）断开与服务器连接。 MQTT服务器端 MQTT服务器以称为\"消息代理\"（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以： （1）接受来自客户的网络连接； （2）接受客户发布的应用信息； （3）处理来自客户端的订阅和退订请求； （4）向订阅的客户转发应用程序消息。 发布/订阅、主题、会话 发布/订阅 MQTT 是基于发布(Publish)/订阅(Subscribe)模式来进行通信及数据交换的，与 HTTP 的请求(Request)/应答(Response)的模式有本质的不同。订阅者(Subscriber)会向消息服务器(Broker)订阅一个主题(Topic)。成功订阅后，消息服务器会将该主题下的消息转发给所有的订阅者。主题(Topic)以 ‘/’ 为分隔符区分不同的层级。 包含通配符 ‘+’ 或 ‘#’ 的主题又称为主题过滤器(Topic Filters); 不含通配符的称为主题名(Topic Names) '+':表示通配一个层级， 例如a/+，匹配a/x,a/y '#':表示通配多个层级， 例如a/#，匹配a/x,a/b/c/d 注:‘+’通配一个层级，’#’通配多个层级(必须在末尾)。 例如: chat/room/1 sensor/10/temperature sensor/+/temperature $SYS/broker/metrics/packets/received $SYS/broker/metrics/# 发布者(Publisher) 只能向 ‘主题名’ 发布消息，订阅者(Subscriber) 则可以通过订阅 ‘主题过滤器’ 来通配多个主题名称。 会话（Session） 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 MQTT协议中的方法 MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有： （1）CONNECT：客户端连接到服务器 （2）CONNACK：连接确认 （3）PUBLISH：发布消息 （4）PUBACK：发布确认 （5）PUBREC：发布的消息已接收 （6）PUBREL：发布的消息已释放 （7）PUBCOMP：发布完成 （8）SUBSCRIBE：订阅请求 （9）SUBACK：订阅确认 （10）UNSUBSCRIBE：取消订阅 （11）UNSUBACK：取消订阅确认 （12）PINGREQ：客户端发送心跳 （13）PINGRESP：服务端心跳响应 （14）DISCONNECT：断开连接 （15）AUTH：认证 MQTT协议数据包结构 官方文档中对于MQTT协议包的结构有着具体的说明: 地址 在MQTT协议中，一个MQTT数据包由： 固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。 MQTT数据包结构如下： （1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识，如连接，发布，订阅，心跳等。其中固定头是必须的，所有类型的MQTT协议中，都必须包含固定头。 （2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。可变头部不是可选的意思，而是指这部分在有些协议类型中存在，在有些协议中不存在。 （3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。与可变头一样，在有些协议类型中有消息内容，有些协议类型中没有消息内容。 固定头（Fixed header） 固定头存在于所有MQTT数据包中，固定头包含两部分内容，首字节(字节1)和剩余消息报文长度(从第二个字节开始，长度为1-4字节)，剩余长度是当前包中剩余内容长度的字节数，包括变量头和有效负载中的数据）。剩余长度不包含用来编码剩余长度的字节。剩余长度使用了一种可变长度的结构来编码，这种结构使用单一字节表示0-127的值。大于127的值如下处理。每个字节的低7位用来编码数据，最高位用来表示是否还有后续字节。因此每个字节可以编码128个值，再加上一个标识位。剩余长度最多可以用四个字节来表示。 可变头(Variable Header) 消息体(Payload) var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/zkclient/":{"url":"doc/zkclient/","title":"ZKClient","keywords":"","body":" var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/zkclient/Curator/":{"url":"doc/zkclient/Curator/","title":"Apache Curator","keywords":"","body":" var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/zkclient/Curator/Curator笔记.html":{"url":"doc/zkclient/Curator/Curator笔记.html","title":"Curator笔记","keywords":"","body":"Curator笔记 参考：地址参考：地址2 var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "},"doc/学习中.html":{"url":"doc/学习中.html","title":"学习中","keywords":"","body":" var gitalk = new Gitalk({ clientID: '4c2fa3d62f2b207e2da4', clientSecret: 'cfeb64e9a617ab3957598b3d1e501f7b9002aca7', repo: 'gitbook-commit', owner: 'runing-time', admin: ['runing-time'], id: md5(location.pathname), }); gitalk.render('gitalk-container'); powered by Gitbook该文件最后修改时间： 2021-05-16 16:43:29 "}}